//===----- BPFMIOffsetReloc.cpp - MI Offset Relocation Adjustment ---------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This pass performs adjustment offset relocation. The IR AbstractMemberAccess
// pass has replaced the constant offset generated by getmemberaddr with
// a global variable. At machine inst level, the code would look like
//
//    ld_imm64 r1, @mangled_offset
//    ldd r2, r1, 0
//    add r3, struct_base_reg, r2
//
// This pass removes "ldd" and generates the below code
//    ld_imm64 r1, @mangled_offset
//    add r3, struct_base_reg, r1
//
// Eventually, at BTF output stage, a relocation record will be generated
// for ld_imm64 which should be replaced later by bpf loader:
//    r1 = <calculated offset>
//    add r3, struct_base_reg, r1
//
//===----------------------------------------------------------------------===//

#include "BPF.h"
#include "BPFInstrInfo.h"
#include "BPFTargetMachine.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"

using namespace llvm;

#define DEBUG_TYPE "bpf-mi-offset-reloc"

namespace {

struct BPFMIOffsetReloc : public MachineFunctionPass {

  static char ID;
  const BPFInstrInfo *TII;
  MachineFunction *MF;

  BPFMIOffsetReloc() : MachineFunctionPass(ID) {
    initializeBPFMIOffsetRelocPass(*PassRegistry::getPassRegistry());
  }

private:
  // Initialize class variables.
  void initialize(MachineFunction &MFParm);

  bool removeOffsetRelocLDD(void);

public:
  // Main entry point for this pass.
  bool runOnMachineFunction(MachineFunction &MF) override {
    if (!skipFunction(MF.getFunction())) {
      initialize(MF);
    }
    return removeOffsetRelocLDD();
  }
};

// Initialize class variables.
void BPFMIOffsetReloc::initialize(MachineFunction &MFParm) {
  MF = &MFParm;
  TII = MF->getSubtarget<BPFSubtarget>().getInstrInfo();
  LLVM_DEBUG(dbgs() << "*** BPF PreEmit offset reloc pass ***\n\n");
}

bool BPFMIOffsetReloc::removeOffsetRelocLDD() {
  MachineRegisterInfo *MRI = &MF->getRegInfo();
  MachineInstr *ToErase = nullptr;
  bool Changed = false;

  for (MachineBasicBlock &MBB : *MF) {
    for (MachineInstr &MI : MBB) {
      if (ToErase) {
        ToErase->eraseFromParent();
        ToErase = nullptr;
      }

      // Ensure the register format is LOAD <reg>, <reg>, 0
      if (MI.getOpcode() != BPF::LDD && MI.getOpcode() != BPF::LDW &&
          MI.getOpcode() != BPF::LDH && MI.getOpcode() != BPF::LDB &&
          MI.getOpcode() != BPF::LDW32 && MI.getOpcode() != BPF::LDH32 &&
          MI.getOpcode() != BPF::LDB32)
        continue;

      if (!MI.getOperand(0).isReg() || !MI.getOperand(1).isReg())
        continue;

      if (!MI.getOperand(2).isImm() || MI.getOperand(2).getImm())
        continue;

      unsigned DstReg = MI.getOperand(0).getReg();
      unsigned SrcReg = MI.getOperand(1).getReg();

      MachineInstr *DefInst = MRI->getUniqueVRegDef(SrcReg);
      if (!DefInst)
        continue;

      bool IsCandidate = false;
      if (DefInst->getOpcode() == BPF::LD_imm64) {
        const MachineOperand &MO = DefInst->getOperand(1);
        if (MO.isGlobal()) {
          const GlobalValue *GVal = MO.getGlobal();
          auto *GVar = dyn_cast<GlobalVariable>(GVal);
          if (GVar) {
            // Global variables representing structure offset or
            // extern globals with section name ".BPF.patchable_externs"
            if (GVar->hasAttribute("btf_ama"))
              IsCandidate = true;
            else if (!GVar->hasInitializer() && GVar->hasExternalLinkage() &&
                     GVar->getSection() == ".BPF.patchable_externs")
              IsCandidate = true;
          }
        }
      }

      if (!IsCandidate)
        continue;

      auto Begin = MRI->use_begin(DstReg), End = MRI->use_end();
      decltype(End) NextI;
      for (auto I = Begin; I != End; I = NextI) {
        NextI = std::next(I);
        I->setReg(SrcReg);
      }

      // BuildMI(MBB, MI, MI.getDebugLoc(), TII->get(BPF::MOV_rr), DstReg)
          // .addReg(SrcReg);
      ToErase = &MI;
      Changed = true;
    }
  }

  return Changed;
}

} // namespace

INITIALIZE_PASS(BPFMIOffsetReloc, DEBUG_TYPE, "BPF PreEmit OffsetReloc",
                false, false)

char BPFMIOffsetReloc::ID = 0;
FunctionPass *llvm::createBPFMIOffsetRelocPass() {
  return new BPFMIOffsetReloc();
}
